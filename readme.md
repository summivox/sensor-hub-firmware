# RNL2 sensor hub firmware
_by Yin Zhong (yinzhong at andrew)_

## On project template and HAL library

I have developed a minimalistic yet functional template (including a transparently buffered DMA-enabled `stdin`/`stdout` implementation) which I'm not going to use in this project simply because I have received complaints about my template "hard to understand or maintain" in the past. While I would certainly dispute as I don't always agree with the design of the "official HAL", which I believe is a monolithic mess of bloatware, I fully expect it to be what most STM32 developers are familiar with. Therefore I am using it together with the Keil ARM toolchain.

EDIT: I rewrote buffered IO on top of "official HAL".

### Code generation with STM32CubeMX

Project scaffold and HAL (peripheral configuratino) code are generated by STM32CubeMX software. Although in theory the software should avoid overwriting user code, it can be unreliable at times, so please follow the following steps when re-generation of code is needed:

1.  Copy `firmware.ioc` and `Src/` to a temporary folder
2.  Open this new copy of `firmware.ioc` in STM32CubeMX and generate code
3.  Copy `Inc/` and `Src/` from temporary folder back to project folder, overwriting everything
4.  Update Keil project manually

Actual code is stored under `user/` instead, with entry point signature:

```cpp
extern "C" void user_main(void);
```

### Keil ARM project

Project settings:

*   Target: Set "Operating system" to `RTX Kernel`
*   C/C++:
    *   ADD `ARM_MATH_CM3` to defines
    *   ADD `..\user`, `..\system` to includes
    *   REMOVE `--C99` option (needed for C++)
*   Debug: Configurate your JTag probe

Source tree:

*   MODIFY `stm32f1xx_it.c` 
    *   Remove function `SysTick_Handler`  
        _reason: needed for RTOS_
    *   Prepend code to DMA interrupt handlers (search for `hdma_usart`)
        If `tx` appears in the line, add:
        ```c
        UART_HandleTypeDef* u = ((UART_HandleTypeDef*)hdma_usart2_tx.Parent);
        if (u->State == HAL_UART_STATE_BUSY_TX_RX) {
            u->State = HAL_UART_STATE_BUSY_RX;
        } else {
            u->State = HAL_UART_STATE_READY;
        }
        ```
        If `rx` appears in the line, add:
        ```c
        UART_HandleTypeDef* u = ((UART_HandleTypeDef*)hdma_usart2_rx.Parent);
        if (u->State == HAL_UART_STATE_BUSY_TX_RX) {
            u->State = HAL_UART_STATE_BUSY_TX;
        } else {
            u->State = HAL_UART_STATE_READY;
        }
        ```
*   ADD `user/*`; `system/*` (into 2 separate groups)


## Bugfix to firmware

### `stm32f1xx_hal_spi.c`

Starting from line 1348:

```c
    /* Reset content of SPI TxDMA descriptor */
    hspi->hdmatx->XferHalfCpltCallback = 0;
    hspi->hdmatx->XferCpltCallback     = 0;
    hspi->hdmatx->XferErrorCallback    = 0;
```

When this SPI is configurated in RX-only master mode, program crashes in hardfault because `hspi->hdmatx == NULL`.

---

Parallel code location: starting from line 1254:

```c
    /* Reset content of SPI RxDMA descriptor */
    hspi->hdmarx->XferHalfCpltCallback = 0;
    hspi->hdmarx->XferCpltCallback     = 0;
    hspi->hdmarx->XferErrorCallback    = 0;
```

If this SPI is configured in TX-only master mode (i.e. RX pin routed to GPIO), program crashes in hardfault because `hspi->hdmarx == NULL`.

---

Starting from line 1330:

```c
    else if((hspi->Init.Direction == SPI_DIRECTION_2LINES)&&(hspi->Init.Mode == SPI_MODE_MASTER))
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hspi);

      /* Call transmit-receive function to send Dummy data on Tx line and generate clock on CLK line */
      return HAL_SPI_TransmitReceive_DMA(hspi, pData, pData, Size);
    }
```

While this doesn't crash, it always returns `HAL_BUSY` instead of doing the transfer, because `hspi->State == HAL_SPI_STATE_BUSY_RX` at that time.
